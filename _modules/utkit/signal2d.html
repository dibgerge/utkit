<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>utkit.signal2d &#8212; UTkit 0.2</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="UTkit 0.2" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <!-- <li><a href="http://project.invalid/">Project Homepage</a> &raquo;</li> -->
    
        <li class="nav-item nav-item-0"><a href="../../index.html">UTkit 0.2</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for utkit.signal2d</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">hilbert</span><span class="p">,</span> <span class="n">get_window</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">griddata</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="k">import</span> <span class="n">fft2</span><span class="p">,</span> <span class="n">fftfreq</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">,</span> <span class="n">ifft2</span>
<span class="kn">from</span> <span class="nn">.signal3d</span> <span class="k">import</span> <span class="n">Signal3D</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>


<div class="viewcode-block" id="Signal2D"><a class="viewcode-back" href="../../generated/utkit.Signal2D.html#utkit.Signal2D">[docs]</a><span class="k">class</span> <span class="nc">Signal2D</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extends :class:`pandas.DataFrame` class to support operations commonly required</span>
<span class="sd">    in radio frequency signals, and especially in ultrasonics. The axis convention used is:</span>

<span class="sd">        * **Axis 1 (columns)**: *X*-direction</span>
<span class="sd">        * **Axis 0 (index)**: *Y*-direction</span>

<span class="sd">    For example, in the context of ultrasonic inspection, the *X*-direction would represent</span>
<span class="sd">    the spatial line scan, and the *Y*-direction represents the signal time base, which can</span>
<span class="sd">    be scaled to represent the ultrasonic beam depth through the material.</span>

<span class="sd">    The class constructor is similar as that of :class:`pandas.DataFrame` with the added</span>
<span class="sd">    option of specifying only the sampling intervals along the *X* and *Y* directions.</span>
<span class="sd">    Thus, if *index* and/or *columns* are scalars, which *data* is a 2-D array, then</span>
<span class="sd">    the Signal2D basis are constructed starting from 0 at the given sampling intervals.</span>

<span class="sd">    If data input is a dictionary, usual rules from :class:`pandas.DataFrame` apply, but index</span>
<span class="sd">    can still be a scalar specifying the sampling interval.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                        <span class="n">datalen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">datalen</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                    <span class="n">datalen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">datalen</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">datalen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">datalen</span><span class="p">)</span> <span class="o">*</span> <span class="n">index</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">datalen</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                    <span class="n">datalen</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">datalen</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                    <span class="n">datalen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">datalen</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">datalen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">datalen</span><span class="p">)</span> <span class="o">*</span> <span class="n">columns</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="c1"># check for axes monotonicity</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Index must be monotonically increasing.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Columns must be monotonically increasing.&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Signal2D</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.signal</span> <span class="k">import</span> <span class="n">Signal</span>
        <span class="k">return</span> <span class="n">Signal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Signal3D</span>

    <span class="k">def</span> <span class="nf">_get_axes_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the numbers of axes, given a list of them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : int, str, list</span>
<span class="sd">            The axes list to be evaluated. axes could be named alias for corresponding axes</span>
<span class="sd">            numbers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list</span>
<span class="sd">            Axes as numbers. If axes was None, all available axes are returned. If axes was a</span>
<span class="sd">            scalar, return a list of size one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axes</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>

<div class="viewcode-block" id="Signal2D.__call__"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.__call__.html#utkit.Signal2D.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate the axes. This function used :func:`scipy.interpolate.griddata`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : array_like</span>
<span class="sd">            New index values to compute the interpolation.</span>

<span class="sd">        columns : array_like</span>
<span class="sd">            New columns values to compute the interpolation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A new Signal2D object computed at the new given axes values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Other keyword arguments are passed directly to the interpolation function</span>
<span class="sd">        :func:`scipy.interpolate.griddata`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">index</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">columns</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">columns</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;New index and columns must be one dimensional arrays.&#39;</span><span class="p">)</span>

        <span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
        <span class="n">new_xg</span><span class="p">,</span> <span class="n">new_yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">((</span><span class="n">yg</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">xg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="n">new_yg</span><span class="p">,</span> <span class="n">new_xg</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal2D.reset_rate"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.reset_rate.html#utkit.Signal2D.reset_rate">[docs]</a>    <span class="k">def</span> <span class="nf">reset_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-samples the Signal to be of a specified sampling rate. The method uses interpolation</span>
<span class="sd">        to recompute the signal values at the new samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : float, array_like (2,)</span>
<span class="sd">            The sampling rate for the axes specified. If it is a scalar, and axes is</span>
<span class="sd">            :const:`None`, the same sampling rate will be set for both axes.</span>

<span class="sd">        axes : {0/&#39;y&#39;/&#39;index&#39;, 1/&#39;x&#39;/&#39;columns&#39;}, optional</span>
<span class="sd">            The axes along which to apply the re-sampling. If it is not set, both axes will be</span>
<span class="sd">            re-sampled.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A copy of the Signal2D with the new sampling rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_val_on_axes</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal2D.operate"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.operate.html#utkit.Signal2D.operate">[docs]</a>    <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the signal according to a given option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        option : string/char, optional</span>
<span class="sd">            The possible options are (combined options are allowed):</span>

<span class="sd">             +--------------------+--------------------------------------+</span>
<span class="sd">             | *option*           | Meaning                              |</span>
<span class="sd">             +====================+======================================+</span>
<span class="sd">             | &#39;&#39; *(Default)*     | Return the raw signal                |</span>
<span class="sd">             +--------------------+--------------------------------------+</span>
<span class="sd">             | &#39;n&#39;                | normalized signal                    |</span>
<span class="sd">             +--------------------+--------------------------------------+</span>
<span class="sd">             | &#39;d&#39;                | decibel value                        |</span>
<span class="sd">             +--------------------+--------------------------------------+</span>

<span class="sd">        axis : int, optional</span>
<span class="sd">            Only used in the case option specified &#39;e&#39; for envelop. Specifies along which axis to</span>
<span class="sd">            compute the envelop.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            The modified Signal2D.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yout</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="s1">&#39;e&#39;</span> <span class="ow">in</span> <span class="n">option</span><span class="p">:</span>
            <span class="c1"># make hilbert transform faster by computing it at powers of 2</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">pwr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="nb">int</span><span class="p">(</span><span class="n">pwr2</span><span class="p">)</span> <span class="k">if</span> <span class="n">pwr2</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="k">else</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pwr2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">yout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hilbert</span><span class="p">(</span><span class="n">yout</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,))</span>
            <span class="n">yout</span> <span class="o">=</span> <span class="n">yout</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="s1">&#39;n&#39;</span> <span class="ow">in</span> <span class="n">option</span><span class="p">:</span>
            <span class="n">yout</span> <span class="o">=</span> <span class="n">yout</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yout</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;d&#39;</span> <span class="ow">in</span> <span class="n">option</span><span class="p">:</span>
            <span class="n">yout</span> <span class="o">=</span> <span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yout</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">yout</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cook_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes size of val based on given axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        val : float, array_like</span>
<span class="sd">            This is the value to be tested</span>

<span class="sd">        axes : array_like</span>
<span class="sd">            The axis for which the *val* corresponds.</span>

<span class="sd">        default : list</span>
<span class="sd">            Default values over all axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : numpy.ndarray</span>
<span class="sd">            A 2-element array representing the filled *val* with missing axis value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>

        <span class="c1"># if val is scalar, make it same size as given axes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span><span class="o">*</span><span class="n">val</span>

        <span class="c1"># if val is an array, make sure it has same size as axes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;value and axes have different lengths.&#39;</span><span class="p">)</span>

        <span class="c1"># if defaults given, fill up all dimensions not specified by axes to default values</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
            <span class="n">default</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="Signal2D.fft"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.fft.html#utkit.Signal2D.fft">[docs]</a>    <span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ssb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Fourier transform in two dimensions, or along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ssb : bool, optional</span>
<span class="sd">            Determines if only the single sided Fourier transform will be returned.</span>

<span class="sd">        axes : int, array_like, optional</span>
<span class="sd">            The axes along which to compute the FFT.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A new signal representing the Fourier transform.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Keyword arguments can be given to the the underlying Fourier transform function</span>
<span class="sd">        :func:`scipy.fftpack.fft2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axes_numbers</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">fval</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">fft2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">fval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">ax</span><span class="p">]))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">ssb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">ax</span><span class="p">][</span><span class="n">coords</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="Signal2D.window"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.window.html#utkit.Signal2D.window">[docs]</a>    <span class="k">def</span> <span class="nf">window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_fcn</span><span class="o">=</span><span class="s1">&#39;boxcar&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a window to the signal within a given time range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index1 : {float, int, array_like}, optional</span>
<span class="sd">            The start index/position of the window. Default value is minimum of index and columns.</span>
<span class="sd">            If *index1* is a two_element array, then it specifies the start positions for both axes.</span>

<span class="sd">        index2 : {float, int, array_like}, optional</span>
<span class="sd">            The end index/position of the window. Default value is maximum of index and columns.</span>
<span class="sd">            If *index2* is a two_element array, then it specifies the end positions for both axes.</span>

<span class="sd">        axes : {int, string, array_like}, optional</span>
<span class="sd">            The axes names/numbers along which to apply the window.</span>

<span class="sd">        win_fcn : string/float/tuple, optional</span>
<span class="sd">            The type of window to create. See the function :func:`scipy.signal.get_window()` for</span>
<span class="sd">            a complete list of available windows, and how to pass extra parameters for a</span>
<span class="sd">            specific window function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Signal:</span>
<span class="sd">            The windowed Signal signal.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">          If the window requires no parameters, then `win_fcn` can be a string.</span>
<span class="sd">          If the window requires parameters, then `win_fcn` must be a tuple</span>
<span class="sd">          with the first argument the string name of the window, and the next</span>
<span class="sd">          arguments the needed parameters. If `win_fcn` is a floating point</span>
<span class="sd">          number, it is interpreted as the beta parameter of the kaiser window.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axes_numbers</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">index2</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>

        <span class="n">win2d</span> <span class="o">=</span> <span class="n">Signal2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="n">win</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="n">st</span><span class="p">,</span> <span class="n">en</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">slice_locs</span><span class="p">(</span><span class="n">index1</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">index2</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span>
            <span class="n">win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">win_fcn</span><span class="p">,</span> <span class="n">en</span> <span class="o">-</span> <span class="n">st</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Case where we want to window the two dimensions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">win</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">win2d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">index2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">index2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">win</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">win</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># aply the same window across the other axis</span>
            <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">win_slice</span> <span class="o">=</span> <span class="n">win2d</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">index1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">index2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">win_slice</span><span class="o">.</span><span class="n">loc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">win</span>
            <span class="n">win2d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">win_slice</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not make window.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">win2d</span></div>

<div class="viewcode-block" id="Signal2D.filter_freq"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.filter_freq.html#utkit.Signal2D.filter_freq">[docs]</a>    <span class="k">def</span> <span class="nf">filter_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">high_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_fcn</span><span class="o">=</span><span class="s1">&#39;boxcar&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a filter in the frequency domain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_freq : scalar, array_like, optional</span>
<span class="sd">            The lower cutoff frequency for the filter. All frequencies less than this will be</span>
<span class="sd">            filtered out. If this is scalar, and *axes* is :const:`None`, then the same</span>
<span class="sd">            low_frequency will be applied for both axes.</span>

<span class="sd">        high_freq : scalar, array_like, optional</span>
<span class="sd">            The upper cutoff frequency for the filter. All frequencies higher than this will be</span>
<span class="sd">            filtered out. If this is scalar, and *axes* is :const:`None`, then the same</span>
<span class="sd">            high_frequency will be applied for both axes.</span>

<span class="sd">        axes : {int, string}, optional</span>
<span class="sd">            The axes along which to filter the 2D signal.</span>

<span class="sd">        win_fcn : {string, tuple}, optional</span>
<span class="sd">            The window type to apply for performing the filtering in the frequency domain. See the</span>
<span class="sd">            function :func:`scipy.signal.get_window()` for a complete list of available windows,</span>
<span class="sd">            and how to pass extra parameters for a specific window function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            The new filtered signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axes_numbers</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">fdomain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">low_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">low_freq</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="n">high_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">high_freq</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">low_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">low_freq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">high_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high_freq</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>

        <span class="n">fupper</span><span class="p">,</span> <span class="n">flower</span> <span class="o">=</span> <span class="n">fdomain</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">fdomain</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">fupper</span> <span class="o">=</span> <span class="n">fupper</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">flower</span> <span class="o">=</span> <span class="n">flower</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">fupper</span> <span class="o">=</span> <span class="n">fupper</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">index1</span><span class="o">=</span><span class="n">low_freq</span><span class="p">,</span> <span class="n">index2</span><span class="o">=</span><span class="n">high_freq</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">win_fcn</span><span class="o">=</span><span class="n">win_fcn</span><span class="p">)</span>
        <span class="n">flower</span> <span class="o">=</span> <span class="n">flower</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">index1</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">high_freq</span><span class="p">),</span> <span class="n">index2</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">low_freq</span><span class="p">),</span>
                               <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">win_fcn</span><span class="o">=</span><span class="n">win_fcn</span><span class="p">)</span>
        <span class="n">fdomain</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fupper</span><span class="p">)</span>
        <span class="n">fdomain</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">flower</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">fdomain</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">ift</span> <span class="o">=</span> <span class="n">ifft2</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="n">axes</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ift</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">psd_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Currently only along the 0 axis.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fc</span>
<span class="sd">        width</span>
<span class="sd">        overlap</span>
<span class="sd">        nfft</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">s_seg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:(</span><span class="n">start</span> <span class="o">+</span> <span class="n">width</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_seg</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_seg</span><span class="p">)</span>
            <span class="n">yf</span> <span class="o">=</span> <span class="n">s_seg</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">ssb</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">width</span> <span class="o">-</span> <span class="n">overlap</span>
            <span class="n">amp</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">yf</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">amp</span>

<div class="viewcode-block" id="Signal2D.shift_axes"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.shift_axes.html#utkit.Signal2D.shift_axes">[docs]</a>    <span class="k">def</span> <span class="nf">shift_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shifts an axis (or both axis) by a specified amount.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift : float, array_like</span>
<span class="sd">            The amount to shift the axis. If *shift* is an array, it should have the same size as</span>
<span class="sd">            *axes*, if specified.</span>

<span class="sd">        axes : int, string, array_like, optional</span>
<span class="sd">            The axes to shift. If not specified, all axes will be shifted by the given *shift*</span>
<span class="sd">            value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A new Signal2D with shifted axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axes_numbers</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Signal2D.scale_axes"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.scale_axes.html#utkit.Signal2D.scale_axes">[docs]</a>    <span class="k">def</span> <span class="nf">scale_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scales a given axis (or both) by a given amount.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : float, array_like</span>
<span class="sd">            The amount to scale the axis. If *scale* is an array, it should have the same size as</span>
<span class="sd">            *axes*, if specified.</span>

<span class="sd">        axes : int/string, optional</span>
<span class="sd">            The axes to scale. If not specified, all axes will be scaled by the given *scale* value.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A copy of Signal2D with scaled axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axes_numbers</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">*</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">*</span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Signal2D.skew"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.skew.html#utkit.Signal2D.skew">[docs]</a>    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a skew transformation on the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float, array_like</span>
<span class="sd">            The angle to skew the Scan2D coordinates. If *angle* is an array, it should</span>
<span class="sd">            have the same size as *axes*. If it is a scalar, the angle will be applied to all</span>
<span class="sd">            specified *axes*</span>

<span class="sd">        axes : integer, str, optional</span>
<span class="sd">            The axis along which to skew. If *axes* is set to :const:`None`, then both axes are</span>
<span class="sd">            skewed.</span>

<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            If const:`True`, realign the skewed axes on a regular grid, and use interpolation to</span>
<span class="sd">            recompute the values of the Signal2D at the new regular grid. The new grid will be</span>
<span class="sd">            computed to span the new range of the axes.</span>

<span class="sd">            Otherwise, no interpolation will be formed, however the grid will be similar to the</span>
<span class="sd">            current object grid. That is, the skewed grid coordinates are reset to match the</span>
<span class="sd">            nearest neighbor from the original grid.</span>

<span class="sd">        ts : float, array_like, optional</span>
<span class="sd">            Only required if *interpolate* is set to :const:`True`. Specifies the sampling</span>
<span class="sd">            interval for the new regular grid used in the interpolation. If not specified,</span>
<span class="sd">            then by default, the current sampling intervals of the Signal2D object will be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        signal2D : Signal2D</span>
<span class="sd">            If *interpolate* is :const:`True`, then a new Signal2D object is returned,</span>
<span class="sd">            after interpolation onto a regular grid.</span>

<span class="sd">        X, Y, val : tuple</span>
<span class="sd">            If *interpolate* is :const:`False`, then a tuple is returned, composed of the the</span>
<span class="sd">            new coordinates (X, Y), where now X and Y are 2-D matrices with same shape as the</span>
<span class="sd">            dataframe. The values are also returned for convenience, but they are the same as the</span>
<span class="sd">            current Signal2D object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axes_numbers</span><span class="p">(</span><span class="n">axes</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">tan_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
        <span class="n">skew_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tan_angle</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">tan_angle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">]])</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
        <span class="n">xskew</span><span class="p">,</span> <span class="n">yskew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">skew_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]))</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xskew</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">yskew</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cook_args</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">)</span>
            <span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="n">yv</span><span class="p">,</span> <span class="n">xv</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
                <span class="n">oldlabels</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">newlabels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">ynew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">]</span>

                <span class="c1"># The following removes the effect at the edges, where the edge values are</span>
                <span class="c1"># extruded into the region outside the frame.</span>
                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                    <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                    <span class="n">smin</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">oldlabels</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ynew</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                    <span class="n">smax</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">max_val</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">oldlabels</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ynew</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                    <span class="n">vals</span><span class="p">[</span><span class="n">newlabels</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">-</span> <span class="n">smin</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">vals</span><span class="p">[</span><span class="n">newlabels</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">-</span> <span class="n">smax</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">ynew</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">xnew</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span></div>

<div class="viewcode-block" id="Signal2D.pad"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.pad.html#utkit.Signal2D.pad">[docs]</a>    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;split&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds padding along the given axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extent : scalar, 2-element array</span>
<span class="sd">            The desired extent of the axis that requires padding. If the given extent is smaller</span>
<span class="sd">            than the current axis extent, the signal2D will be truncated.</span>

<span class="sd">        axes : {0/&#39;y&#39;/index or 1/&#39;x&#39;/&#39;columns, None}</span>
<span class="sd">            The axes along which to apply the padding. If :const:`None` is specified, then the</span>
<span class="sd">            Signal2D will be padded along both axes.</span>

<span class="sd">        fill : {&#39;min&#39;, &#39;max&#39;, scalar}, optional</span>
<span class="sd">            The value to fill the padded regions:</span>
<span class="sd">                * &#39;min&#39;: Pad with values of the minimum amplitude in the signal.</span>
<span class="sd">                * &#39;max&#39;: Pad with the value of the maximum amplitude in the signal.</span>
<span class="sd">                * scalar: otherwise, a custom scalar value can be specified for the padding.</span>

<span class="sd">        position : {&#39;start&#39;, &#39;end&#39;, &#39;split&#39;}</span>
<span class="sd">            How to apply the padding to the Signal2D:</span>
<span class="sd">                * &#39;start&#39; : apply the padding at the beginning of the axes. i.e., to the left for</span>
<span class="sd">                  the columns, and to the top for the index.</span>
<span class="sd">                * &#39;end&#39; : apply the padding at the end of the axes.</span>
<span class="sd">                * &#39;split&#39;: split the padding to be half at the start and half at the end. If the</span>
<span class="sd">                  number of samples padded is odd, then the end will have one more sample padded</span>
<span class="sd">                  than the start.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A new Signal2D object will the axes padded. The sampling interval of the padded</span>
<span class="sd">            region is equal to the mean sampling rate of the corresponding axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_val_on_axes</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">))</span>
        <span class="n">npad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="n">npad_start</span><span class="p">,</span> <span class="n">npad_end</span> <span class="o">=</span> <span class="n">npad</span><span class="p">,</span> <span class="n">npad</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
            <span class="n">npad_start</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="n">npad_end</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;split&#39;</span><span class="p">:</span>
            <span class="n">npad_start</span><span class="p">,</span> <span class="n">npad_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">npad</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">npad</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown value for position.&#39;</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">npad_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">npad_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">left_part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npad_start</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">right_part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">npad_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">left_part</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">right_part</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="n">npad_start</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">npad_end</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">fill</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">fill</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">pad_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This allows padding by specifying the start and end of the coordinates for each of the axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : 2-element array, optional</span>
<span class="sd">            Specifies the start and end of the index.</span>

<span class="sd">        columns : 2-element array, optional</span>
<span class="sd">            Specified the start and end of the columns.</span>

<span class="sd">        fill : float, optional</span>
<span class="sd">             The value to fill the padded regions:</span>
<span class="sd">                * &#39;min&#39;: Pad with values of the minimum amplitude in the signal.</span>
<span class="sd">                * &#39;max&#39;: Pad with the value of the maximum amplitude in the signal.</span>
<span class="sd">                * scalar: otherwise, a custom scalar value can be specified for the padding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            The padded signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;index_range should have a size of 2.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;columns_range should have a size of 2.&#39;</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># find values less than x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>
        <span class="c1"># out.loc[out.index &lt; self.index[0]] = fill</span>
        <span class="c1"># out.loc[out.index &gt; self.index[-1]] = fill</span>
        <span class="c1"># out.loc[:, out.columns &lt; self.columns[0]] = fill</span>
        <span class="c1"># out.loc[:, out.columns &gt; self.columns[-1]] = fill</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="Signal2D.flip"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.flip.html#utkit.Signal2D.flip">[docs]</a>    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flips the values without flipping corresponding X/Y-axes coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : int/string, optional</span>
<span class="sd">            The axis along which to flip the values. axis can be 0/&#39;y&#39;/&#39;index&#39;. or 1/&#39;x&#39;/&#39;columns&#39;.</span>
<span class="sd">            If axis is set to :const:`None`, both axes will be flipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A copy of Signal2D with axis flipped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_axes_as_num</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal2D.roll"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.roll.html#utkit.Signal2D.roll">[docs]</a>    <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Circular shift by a given value, along a given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : float</span>
<span class="sd">            The amount (in X-Y coordinates units) to shift.</span>

<span class="sd">        axes : string/int, optional</span>
<span class="sd">            The axis along which to shift. Options are 0/&#39;Y&#39;/&#39;index&#39; or 1/&#39;X&#39;/columns. By default,</span>
<span class="sd">            the uFrame is flattened before shifting, after which the original shape is restored.</span>
<span class="sd">            See numpy.roll for more information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A copy of Signal2D after applying the circular shift.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_axes_as_num</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_val_on_axes</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
        <span class="n">out_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">value</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">ax</span><span class="p">]))</span>
            <span class="n">out_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">out_val</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Signal2D</span><span class="p">(</span><span class="n">out_val</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal2D.max_point"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.max_point.html#utkit.Signal2D.max_point">[docs]</a>    <span class="k">def</span> <span class="nf">max_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the (x, y) coordinates of the points that has the maximum amplitude.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, y : ((2,) tuple)</span>
<span class="sd">            The (x, y) coordinates of the Signal2D maximum amplitude.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>

<div class="viewcode-block" id="Signal2D.flatten"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.flatten.html#utkit.Signal2D.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flattens the Signal2D to give coordinates (X, Y, Values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, y, z : numpy.ndarray</span>
<span class="sd">            The X-coordinates, Y-coordinates, Values of the Signal2D.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xv</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yv</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span></div>

<div class="viewcode-block" id="Signal2D.remove_mean"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.remove_mean.html#utkit.Signal2D.remove_mean">[docs]</a>    <span class="k">def</span> <span class="nf">remove_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the mean along a given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : string/int, optional</span>
<span class="sd">            The axis along  which to remove the means. If axis not specified, remove the global</span>
<span class="sd">            mean along all axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal2D</span>
<span class="sd">            A copy of signal2D with means subtracted along given axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axes_numbers</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Signal2D.extract"><a class="viewcode-back" href="../../generated/generated/utkit.Signal2D.extract.html#utkit.Signal2D.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts a 1-D Signal depending on the given option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to extract the :class:`Signal`. Options are 0/&#39;y&#39;/&#39;index&#39; or</span>
<span class="sd">            1/&#39;x&#39;/&#39;columns&#39;.</span>

<span class="sd">        option : {&#39;max&#39;}, optional</span>
<span class="sd">            Currently only the option ``max`` is supported. This returns the signal at the</span>
<span class="sd">            maximum point in the Signal2D.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Signal</span>
<span class="sd">            A new :class:`Signal` object representing the extracted signal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_axes_as_num</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis cannot be None, or an array.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">option</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_point</span><span class="p">()</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">elif</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown axis value.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown option value.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coord</span><span class="p">,</span> <span class="n">out</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the signal sampling period. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convenience property to return X-axis coordinates as ndarray. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convenience property to return Y-axis coordinates as ndarray. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the extents of the axes values&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>


<span class="n">Signal2D</span><span class="o">.</span><span class="n">_setup_axes</span><span class="p">([</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">],</span> <span class="n">info_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">axes_are_reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">aliases</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rows&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <!-- <li><a href="http://project.invalid/">Project Homepage</a> &raquo;</li> -->
    
        <li class="nav-item nav-item-0"><a href="../../index.html">UTkit 0.2</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Gerges Dib.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>