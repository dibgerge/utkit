<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pandas.core.panel &#8212; UTkit 0.2</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="UTkit 0.2" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <!-- <li><a href="http://project.invalid/">Project Homepage</a> &raquo;</li> -->
    
        <li class="nav-item nav-item-0"><a href="../../../index.html">UTkit 0.2</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pandas.core.panel</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Contains data structures designed for manipulating panel (3-dimensional) data</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=E1103,W0231,W0212,W0621</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pandas.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">import</span> <span class="nn">pandas.core.ops</span> <span class="k">as</span> <span class="nn">ops</span>
<span class="kn">import</span> <span class="nn">pandas.core.missing</span> <span class="k">as</span> <span class="nn">missing</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="k">import</span> <span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">OrderedDefaultdict</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="k">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.core.categorical</span> <span class="k">import</span> <span class="n">Categorical</span>
<span class="kn">from</span> <span class="nn">pandas.core.common</span> <span class="k">import</span> <span class="p">(</span><span class="n">PandasError</span><span class="p">,</span> <span class="n">_try_sort</span><span class="p">,</span> <span class="n">_default_index</span><span class="p">,</span>
                                <span class="n">_infer_dtype_from_scalar</span><span class="p">,</span> <span class="n">is_list_like</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="k">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">pandas.core.generic</span> <span class="k">import</span> <span class="n">NDFrame</span><span class="p">,</span> <span class="n">_shared_docs</span>
<span class="kn">from</span> <span class="nn">pandas.core.index</span> <span class="k">import</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">_ensure_index</span><span class="p">,</span>
                               <span class="n">_get_combined_index</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.formats.printing</span> <span class="k">import</span> <span class="n">pprint_thing</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexing</span> <span class="k">import</span> <span class="n">maybe_droplevels</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="k">import</span> <span class="p">(</span><span class="n">BlockManager</span><span class="p">,</span>
                                   <span class="n">create_block_manager_from_arrays</span><span class="p">,</span>
                                   <span class="n">create_block_manager_from_blocks</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="k">import</span> <span class="n">_op_descriptions</span>
<span class="kn">from</span> <span class="nn">pandas.core.series</span> <span class="k">import</span> <span class="n">Series</span>
<span class="kn">from</span> <span class="nn">pandas.tools.util</span> <span class="k">import</span> <span class="n">cartesian_product</span>
<span class="kn">from</span> <span class="nn">pandas.util.decorators</span> <span class="k">import</span> <span class="p">(</span><span class="n">deprecate</span><span class="p">,</span> <span class="n">Appender</span><span class="p">,</span> <span class="n">deprecate_kwarg</span><span class="p">)</span>

<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;items, major_axis, minor_axis&#39;</span><span class="p">,</span>
    <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;Panel&quot;</span><span class="p">,</span>
    <span class="n">axes_single_arg</span><span class="o">=</span><span class="s2">&quot;{0, 1, 2, &#39;items&#39;, &#39;major_axis&#39;, &#39;minor_axis&#39;}&quot;</span><span class="p">)</span>
<span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s1">&#39;args_transpose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;three positional arguments: each one&quot;</span>
                                        <span class="s2">&quot;of</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                        <span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s1">&#39;axes_single_arg&#39;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_ensure_like_indices</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">panels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes sure that time and panels are conformable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">n_panel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">panels</span><span class="p">)</span>
    <span class="n">u_panels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">panels</span><span class="p">)</span>  <span class="c1"># this sorts!</span>
    <span class="n">u_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_time</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_time</span><span class="p">:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">u_time</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_panels</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_panels</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_panel</span><span class="p">:</span>
        <span class="n">panels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">u_panels</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_time</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">panels</span>


<span class="k">def</span> <span class="nf">panel_index</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">panels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a multi-index suitable for a panel-like DataFrame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : array-like</span>
<span class="sd">        Time index, does not have to repeat</span>
<span class="sd">    panels : array-like</span>
<span class="sd">        Panel index, does not have to repeat</span>
<span class="sd">    names : list, optional</span>
<span class="sd">        List containing the names of the indices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    multi_index : MultiIndex</span>
<span class="sd">        Time index is the first level, the panels are the second level.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; years = range(1960,1963)</span>
<span class="sd">    &gt;&gt;&gt; panels = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="sd">    &gt;&gt;&gt; panel_idx = panel_index(years, panels)</span>
<span class="sd">    &gt;&gt;&gt; panel_idx</span>
<span class="sd">    MultiIndex([(1960, &#39;A&#39;), (1961, &#39;A&#39;), (1962, &#39;A&#39;), (1960, &#39;B&#39;),</span>
<span class="sd">                (1961, &#39;B&#39;), (1962, &#39;B&#39;), (1960, &#39;C&#39;), (1961, &#39;C&#39;),</span>
<span class="sd">                (1962, &#39;C&#39;)], dtype=object)</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; years = np.repeat(range(1960,1963), 3)</span>
<span class="sd">    &gt;&gt;&gt; panels = np.tile([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], 3)</span>
<span class="sd">    &gt;&gt;&gt; panel_idx = panel_index(years, panels)</span>
<span class="sd">    &gt;&gt;&gt; panel_idx</span>
<span class="sd">    MultiIndex([(1960, &#39;A&#39;), (1960, &#39;B&#39;), (1960, &#39;C&#39;), (1961, &#39;A&#39;),</span>
<span class="sd">                (1961, &#39;B&#39;), (1961, &#39;C&#39;), (1962, &#39;A&#39;), (1962, &#39;B&#39;),</span>
<span class="sd">                (1962, &#39;C&#39;)], dtype=object)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;panel&#39;</span><span class="p">]</span>
    <span class="n">time</span><span class="p">,</span> <span class="n">panels</span> <span class="o">=</span> <span class="n">_ensure_like_indices</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">panels</span><span class="p">)</span>
    <span class="n">time_factor</span> <span class="o">=</span> <span class="n">Categorical</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">panel_factor</span> <span class="o">=</span> <span class="n">Categorical</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">panels</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_factor</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">panel_factor</span><span class="o">.</span><span class="n">codes</span><span class="p">]</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_factor</span><span class="o">.</span><span class="n">categories</span><span class="p">,</span> <span class="n">panel_factor</span><span class="o">.</span><span class="n">categories</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">sortorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Panel</span><span class="p">(</span><span class="n">NDFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents wide format panel data, stored as 3-dimensional array</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray (items x major x minor), or dict of DataFrames</span>
<span class="sd">    items : Index or array-like</span>
<span class="sd">        axis=0</span>
<span class="sd">    major_axis : Index or array-like</span>
<span class="sd">        axis=1</span>
<span class="sd">    minor_axis : Index or array-like</span>
<span class="sd">        axis=2</span>
<span class="sd">    dtype : dtype, default None</span>
<span class="sd">        Data type to force, otherwise infer</span>
<span class="sd">    copy : boolean, default False</span>
<span class="sd">        Copy data from inputs. Only affects DataFrame / 2d ndarray input</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_constructor_sliced</span> <span class="o">=</span> <span class="n">DataFrame</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">major_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minor_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">major_axis</span><span class="o">=</span><span class="n">major_axis</span><span class="p">,</span>
                        <span class="n">minor_axis</span><span class="o">=</span><span class="n">minor_axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate ND initialization; axes are passed</span>
<span class="sd">        as required objects to __init__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">passed_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;_init_data() got an unexpected keyword &#39;</span>
                            <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">passed_axes</span><span class="p">):</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span>
                        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">passed_axes</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">axes</span><span class="p">)]</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">passed_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">passed_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">lib</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">passed_axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">_infer_dtype_from_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">passed_axes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_matrix</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">passed_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                    <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="n">PandasError</span><span class="p">(</span><span class="s1">&#39;Panel constructor not properly called!&#39;</span><span class="p">)</span>

        <span class="n">NDFrame</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">haxis</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_number</span><span class="p">)</span>

        <span class="c1"># prefilter if haxis passed</span>
        <span class="k">if</span> <span class="n">haxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">haxis</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">haxis</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                               <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">haxis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">):</span>
                <span class="n">ks</span> <span class="o">=</span> <span class="n">_try_sort</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>
            <span class="n">haxis</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># extract axis for remaining axes &amp; create the slicemap</span>
        <span class="n">raxes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">a</span>
                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">)]</span>
        <span class="n">raxes_sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_axes_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raxes</span><span class="p">)</span>

        <span class="c1"># shallow copy</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">haxis_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">raxes</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">haxis</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">haxis_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">raxes_sm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">values</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">haxis</span><span class="p">,</span> <span class="p">[</span><span class="n">haxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">raxes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_names</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">create_block_manager_from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">arr_names</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">intersect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;items&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct Panel from dict of DataFrame objects</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : dict</span>
<span class="sd">            {field : DataFrame}</span>
<span class="sd">        intersect : boolean</span>
<span class="sd">            Intersect indexes of input DataFrames</span>
<span class="sd">        orient : {&#39;items&#39;, &#39;minor&#39;}, default &#39;items&#39;</span>
<span class="sd">            The &quot;orientation&quot; of the data. If the keys of the passed dict</span>
<span class="sd">            should be the items of the result panel, pass &#39;items&#39;</span>
<span class="sd">            (default). Otherwise if the columns of the values of the passed</span>
<span class="sd">            DataFrame objects should be the items (which in the case of</span>
<span class="sd">            mixed-dtype data you should do), instead pass &#39;minor&#39;</span>
<span class="sd">        dtype : dtype, default None</span>
<span class="sd">            Data type to force, otherwise infer</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Panel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orient</span> <span class="o">=</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">orient</span> <span class="o">==</span> <span class="s1">&#39;minor&#39;</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">OrderedDefaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
                    <span class="n">new_data</span><span class="p">[</span><span class="n">item</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">elif</span> <span class="n">orient</span> <span class="o">!=</span> <span class="s1">&#39;items&#39;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Orientation must be one of {items, minor}.&#39;</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_homogenize_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">intersect</span><span class="o">=</span><span class="n">intersect</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">OrderedDict</span><span class="p">):</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ks</span><span class="p">))</span>
        <span class="n">d</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_multilevel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_getitem_multilevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">result_index</span> <span class="o">=</span> <span class="n">maybe_droplevels</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>

            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_index</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prep_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;failed to cast to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">fixed_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">_default_index</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">fixed_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">create_block_manager_from_blocks</span><span class="p">([</span><span class="n">values</span><span class="p">],</span> <span class="n">fixed_axes</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Comparison methods</span>

    <span class="k">def</span> <span class="nf">_compare_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Can only compare identically-labeled &#39;</span>
                            <span class="s1">&#39;same type objects&#39;</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">new_data</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Magic methods</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for a particular Panel</span>

<span class="sd">        Invoked by unicode(df) in py2 only.</span>
<span class="sd">        Yields a Unicode String in both py2/py3.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">class_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s1">&#39;Dimensions: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">shape</span><span class="p">)])</span>

        <span class="k">def</span> <span class="nf">axis_pretty</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">u</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> axis: </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span>
                                                 <span class="n">pprint_thing</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                 <span class="n">pprint_thing</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">u</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> axis: None&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">a</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>

        <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="n">class_name</span><span class="p">,</span> <span class="n">dims</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">axis_pretty</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_get_plane_axes_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get my plane axes indexes: these are already</span>
<span class="sd">        (as compared with higher level planes),</span>
<span class="sd">        as we are returning a DataFrame axes indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis_name</span> <span class="o">==</span> <span class="s1">&#39;major_axis&#39;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="s1">&#39;minor_axis&#39;</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="s1">&#39;items&#39;</span>
        <span class="k">if</span> <span class="n">axis_name</span> <span class="o">==</span> <span class="s1">&#39;minor_axis&#39;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="s1">&#39;major_axis&#39;</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="s1">&#39;items&#39;</span>
        <span class="k">elif</span> <span class="n">axis_name</span> <span class="o">==</span> <span class="s1">&#39;items&#39;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="s1">&#39;major_axis&#39;</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="s1">&#39;minor_axis&#39;</span>

        <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span>

    <span class="k">def</span> <span class="nf">_get_plane_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get my plane axes indexes: these are already</span>
<span class="sd">        (as compared with higher level planes),</span>
<span class="sd">        as we are returning a DataFrame axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axi</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">axi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plane_axes_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)]</span>

    <span class="n">fromDict</span> <span class="o">=</span> <span class="n">from_dict</span>

    <span class="k">def</span> <span class="nf">to_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;block&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to SparsePanel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : float, default NaN</span>
<span class="sd">        kind : {&#39;block&#39;, &#39;integer&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : SparseDataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.sparse</span> <span class="k">import</span> <span class="n">SparsePanel</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">SparsePanel</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">,</span>
                           <span class="n">major_axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span>
                           <span class="n">minor_axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">,</span> <span class="n">default_kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                           <span class="n">default_fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_excel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write each DataFrame in Panel to a separate excel sheet</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string or ExcelWriter object</span>
<span class="sd">            File path or existing ExcelWriter</span>
<span class="sd">        na_rep : string, default &#39;&#39;</span>
<span class="sd">            Missing data representation</span>
<span class="sd">        engine : string, default None</span>
<span class="sd">            write engine to use - you can also set this via the options</span>
<span class="sd">            ``io.excel.xlsx.writer``, ``io.excel.xls.writer``, and</span>
<span class="sd">            ``io.excel.xlsm.writer``.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        float_format : string, default None</span>
<span class="sd">            Format string for floating point numbers</span>
<span class="sd">        cols : sequence, optional</span>
<span class="sd">            Columns to write</span>
<span class="sd">        header : boolean or list of string, default True</span>
<span class="sd">            Write out column names. If a list of string is given it is</span>
<span class="sd">            assumed to be aliases for the column names</span>
<span class="sd">        index : boolean, default True</span>
<span class="sd">            Write row names (index)</span>
<span class="sd">        index_label : string or sequence, default None</span>
<span class="sd">            Column label for index column(s) if desired. If None is given, and</span>
<span class="sd">            `header` and `index` are True, then the index names are used. A</span>
<span class="sd">            sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        startrow : upper left cell row to dump data frame</span>
<span class="sd">        startcol : upper left cell column to dump data frame</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Keyword arguments (and na_rep) are passed to the ``to_excel`` method</span>
<span class="sd">        for each DataFrame written.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.excel</span> <span class="k">import</span> <span class="n">ExcelWriter</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">ExcelWriter</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">path</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;na_rep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_rep</span>

        <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">as_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Getting and setting elements</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quickly retrieve single value at (item, major, minor) location</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : item label (panel item)</span>
<span class="sd">        major : major axis label (panel item row)</span>
<span class="sd">        minor : minor axis label (panel item column)</span>
<span class="sd">        takeable : interpret the passed labels as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : scalar value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">nreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span>

        <span class="c1"># require an arg for each axis</span>
        <span class="k">if</span> <span class="n">nargs</span> <span class="o">!=</span> <span class="n">nreq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;There must be an argument for each axis, you gave&#39;</span>
                            <span class="s1">&#39; </span><span class="si">{0}</span><span class="s1"> args, but </span><span class="si">{1}</span><span class="s1"> are required&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nargs</span><span class="p">,</span>
                                                                     <span class="n">nreq</span><span class="p">))</span>
        <span class="n">takeable</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;takeable&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;get_value() got an unexpected keyword &#39;</span>
                            <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">takeable</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iget_item_cache</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">lower</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">takeable</span><span class="o">=</span><span class="n">takeable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quickly set single value at (item, major, minor) location</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : item label (panel item)</span>
<span class="sd">        major : major axis label (panel item row)</span>
<span class="sd">        minor : minor axis label (panel item column)</span>
<span class="sd">        value : scalar</span>
<span class="sd">        takeable : interpret the passed labels as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        panel : Panel</span>
<span class="sd">            If label combo is contained, will be reference to calling Panel,</span>
<span class="sd">            otherwise a new object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># require an arg for each axis and the value</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">nreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">nargs</span> <span class="o">!=</span> <span class="n">nreq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;There must be an argument for each axis plus the &#39;</span>
                            <span class="s1">&#39;value provided, you gave </span><span class="si">{0}</span><span class="s1"> args, but </span><span class="si">{1}</span><span class="s1"> are &#39;</span>
                            <span class="s1">&#39;required&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nargs</span><span class="p">,</span> <span class="n">nreq</span><span class="p">))</span>
        <span class="n">takeable</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;takeable&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;set_value() got an unexpected keyword &#39;</span>
                            <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">takeable</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iget_item_cache</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">lower</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">takeable</span><span class="o">=</span><span class="n">takeable</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_axes</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">likely_dtype</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_infer_dtype_from_scalar</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">made_bigger</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>
            <span class="c1"># how to make this logic simpler?</span>
            <span class="k">if</span> <span class="n">made_bigger</span><span class="p">:</span>
                <span class="n">com</span><span class="o">.</span><span class="n">_possibly_cast_item</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">likely_dtype</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_box_item_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># a dup selection will yield a full ndim</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape of value must be </span><span class="si">{0}</span><span class="s1">, shape of given &#39;</span>
                                 <span class="s1">&#39;object was </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                     <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">))))</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lib</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">dtype</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">_infer_dtype_from_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot set item of type: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">NDFrame</span><span class="o">.</span><span class="n">_set_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unpickle_panel_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="s2">&quot;Unpickle the panel&quot;</span>
        <span class="n">_unpickle</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_unpickle_array</span>
        <span class="n">vals</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">state</span>

        <span class="n">items</span> <span class="o">=</span> <span class="n">_unpickle</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="n">major</span> <span class="o">=</span> <span class="n">_unpickle</span><span class="p">(</span><span class="n">major</span><span class="p">)</span>
        <span class="n">minor</span> <span class="o">=</span> <span class="n">_unpickle</span><span class="p">(</span><span class="n">minor</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_unpickle</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="n">wp</span> <span class="o">=</span> <span class="n">Panel</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="nf">conform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;items&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conform input DataFrame to align with chosen axis pair.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frame : DataFrame</span>
<span class="sd">        axis : {&#39;items&#39;, &#39;major&#39;, &#39;minor&#39;}</span>

<span class="sd">            Axis the input corresponds to. E.g., if axis=&#39;major&#39;, then</span>
<span class="sd">            the frame&#39;s columns would be items, and the index would be</span>
<span class="sd">            values of the minor axis</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plane_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frame</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_axes_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Round each value in Panel to a specified number of decimal places.</span>

<span class="sd">        .. versionadded:: 0.18.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decimals : int</span>
<span class="sd">            Number of decimal places to round to (default: 0).</span>
<span class="sd">            If decimals is negative, it specifies the number of</span>
<span class="sd">            positions to the left of the decimal point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Panel object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.around</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_round</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">decimals</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;decimals must be an integer&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_needs_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; don&#39;t allow a multi reindex on Panel or above ndim &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop 2D from panel, holding passed axis constant</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis to hold constant. E.g. axis=1 will drop major_axis entries</span>
<span class="sd">            having a certain amount of NA data</span>
<span class="sd">        how : {&#39;all&#39;, &#39;any&#39;}, default &#39;any&#39;</span>
<span class="sd">            &#39;any&#39;: one or more values are NA in the DataFrame along the</span>
<span class="sd">            axis. For &#39;all&#39; they all must be.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, do operation inplace and return None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Panel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">axis</span><span class="p">]))):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">per_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">==</span> <span class="n">per_slice</span>

        <span class="n">new_ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)[</span><span class="n">cond</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">new_ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Panel</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_panel</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_frame</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lib</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not supported in combine &quot;</span>
                                      <span class="s2">&quot;operation with </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                      <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))))</span>

    <span class="k">def</span> <span class="nf">_combine_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plane_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_panel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
        <span class="n">major</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">major_axis</span><span class="p">)</span>
        <span class="n">minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">)</span>

        <span class="c1"># could check that everything&#39;s the same size, but forget it</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">major</span><span class="o">=</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="n">minor</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">major</span><span class="o">=</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="n">minor</span><span class="p">)</span>

        <span class="n">result_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result_values</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">major_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return slice of panel along major axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>
<span class="sd">            Major axis label</span>
<span class="sd">        copy : boolean [deprecated]</span>
<span class="sd">            Whether to make a copy of the data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : DataFrame</span>
<span class="sd">            index -&gt; minor axis, columns -&gt; items</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        major_xs is only for getting, not setting values.</span>

<span class="sd">        MultiIndex Slicers is a generic way to get/set values on any level or</span>
<span class="sd">        levels and is a superset of major_xs functionality, see</span>
<span class="sd">        :ref:`MultiIndex Slicers &lt;advanced.mi_slicers&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;copy keyword is deprecated, &quot;</span>
                          <span class="s2">&quot;default is to return a copy or a view if possible&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">minor_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return slice of panel along minor axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>
<span class="sd">            Minor axis label</span>
<span class="sd">        copy : boolean [deprecated]</span>
<span class="sd">            Whether to make a copy of the data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : DataFrame</span>
<span class="sd">            index -&gt; major axis, columns -&gt; items</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        minor_xs is only for getting, not setting values.</span>

<span class="sd">        MultiIndex Slicers is a generic way to get/set values on any level or</span>
<span class="sd">        levels and is a superset of minor_xs functionality, see</span>
<span class="sd">        :ref:`MultiIndex Slicers &lt;advanced.mi_slicers&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;copy keyword is deprecated, &quot;</span>
                          <span class="s2">&quot;default is to return a copy or a view if possible&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return slice of panel along selected axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>
<span class="sd">            Label</span>
<span class="sd">        axis : {&#39;items&#39;, &#39;major&#39;, &#39;minor}, default 1/&#39;major&#39;</span>
<span class="sd">        copy : boolean [deprecated]</span>
<span class="sd">            Whether to make a copy of the data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : ndim(self)-1</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        xs is only for getting, not setting values.</span>

<span class="sd">        MultiIndex Slicers is a generic way to get/set values on any level or</span>
<span class="sd">        levels and  is a superset of xs functionality, see</span>
<span class="sd">        :ref:`MultiIndex Slicers &lt;advanced.mi_slicers&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;copy keyword is deprecated, &quot;</span>
                          <span class="s2">&quot;default is to return a copy or a view if possible&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="n">axis_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_number</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_return_type</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">is_mixed_type</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">_xs</span> <span class="o">=</span> <span class="n">xs</span>

    <span class="k">def</span> <span class="nf">_ixs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        i : int, slice, or sequence of integers</span>
<span class="sd">        axis : int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># xs cannot handle a non-scalar key, so just reindex here</span>
        <span class="c1"># if we have a multi-index and a single tuple, then its a reduction</span>
        <span class="c1"># (GH 7516)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span> <span class="n">key</span><span class="p">}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">indexer</span><span class="p">)</span>

        <span class="c1"># a reduction</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">iget</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_item_values</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

        <span class="c1"># xs by position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_return_type</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group data on given axis, returning GroupBy object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            Mapping function for chosen access</span>
<span class="sd">        axis : {&#39;major&#39;, &#39;minor&#39;, &#39;items&#39;}, default &#39;major&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grouped : PanelGroupBy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.groupby</span> <span class="k">import</span> <span class="n">PanelGroupBy</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PanelGroupBy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_observations</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform wide format into long (stacked) format as DataFrame whose</span>
<span class="sd">        columns are the Panel&#39;s items and whose index is a MultiIndex formed</span>
<span class="sd">        of the Panel&#39;s major and minor axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_observations : boolean, default True</span>
<span class="sd">            Drop (major, minor) pairs without a complete set of observations</span>
<span class="sd">            across all the items</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">filter_observations</span><span class="p">:</span>
            <span class="c1"># shaped like the return DataFrame</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># size = mask.sum()</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># size = N * K</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">selector</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">construct_multi_parts</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n_repeat</span><span class="p">,</span> <span class="n">n_shuffle</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">axis_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">to_hierarchical</span><span class="p">(</span><span class="n">n_repeat</span><span class="p">,</span> <span class="n">n_shuffle</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">selector</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">axis_idx</span><span class="o">.</span><span class="n">labels</span><span class="p">]</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">axis_idx</span><span class="o">.</span><span class="n">levels</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">axis_idx</span><span class="o">.</span><span class="n">names</span>
            <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">levels</span><span class="p">,</span> <span class="n">names</span>

        <span class="k">def</span> <span class="nf">construct_index_parts</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">major</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">major</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">K</span><span class="p">)[</span><span class="n">selector</span><span class="p">]]</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;major&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">selector</span><span class="p">]]</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;minor&#39;</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">levels</span><span class="p">,</span> <span class="n">names</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">major_labels</span><span class="p">,</span> <span class="n">major_levels</span><span class="p">,</span> <span class="n">major_names</span> <span class="o">=</span> <span class="n">construct_multi_parts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span> <span class="n">n_repeat</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">major_labels</span><span class="p">,</span> <span class="n">major_levels</span><span class="p">,</span> <span class="n">major_names</span> <span class="o">=</span> <span class="n">construct_index_parts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">minor_labels</span><span class="p">,</span> <span class="n">minor_levels</span><span class="p">,</span> <span class="n">minor_names</span> <span class="o">=</span> <span class="n">construct_multi_parts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">,</span> <span class="n">n_repeat</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">n_shuffle</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minor_labels</span><span class="p">,</span> <span class="n">minor_levels</span><span class="p">,</span> <span class="n">minor_names</span> <span class="o">=</span> <span class="n">construct_index_parts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">,</span> <span class="n">major</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">levels</span> <span class="o">=</span> <span class="n">major_levels</span> <span class="o">+</span> <span class="n">minor_levels</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">major_labels</span> <span class="o">+</span> <span class="n">minor_labels</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">major_names</span> <span class="o">+</span> <span class="n">minor_names</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                           <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

    <span class="n">to_long</span> <span class="o">=</span> <span class="n">deprecate</span><span class="p">(</span><span class="s1">&#39;to_long&#39;</span><span class="p">,</span> <span class="n">to_frame</span><span class="p">)</span>
    <span class="n">toLong</span> <span class="o">=</span> <span class="n">deprecate</span><span class="p">(</span><span class="s1">&#39;toLong&#39;</span><span class="p">,</span> <span class="n">to_frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies function along axis (or axes) of the Panel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function to apply to each combination of &#39;other&#39; axes</span>
<span class="sd">            e.g. if axis = &#39;items&#39;, the combination of major_axis/minor_axis</span>
<span class="sd">            will each be passed as a Series; if axis = (&#39;items&#39;, &#39;major&#39;),</span>
<span class="sd">            DataFrames of items &amp; major axis will be passed</span>
<span class="sd">        axis : {&#39;items&#39;, &#39;minor&#39;, &#39;major&#39;}, or {0, 1, 2}, or a tuple with two</span>
<span class="sd">            axes</span>
<span class="sd">        Additional keyword arguments will be passed as keywords to the function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Returns a Panel with the square root of each element</span>

<span class="sd">        &gt;&gt;&gt; p = pd.Panel(np.random.rand(4,3,2))</span>
<span class="sd">        &gt;&gt;&gt; p.apply(np.sqrt)</span>

<span class="sd">        Equivalent to p.sum(1), returning a DataFrame</span>

<span class="sd">        &gt;&gt;&gt; p.apply(lambda x: x.sum(), axis=1)</span>

<span class="sd">        Equivalent to previous:</span>

<span class="sd">        &gt;&gt;&gt; p.apply(lambda x: x.sum(), axis=&#39;minor&#39;)</span>

<span class="sd">        Return the shapes of each DataFrame over axis 2 (i.e the shapes of</span>
<span class="sd">        items x major), as a Series</span>

<span class="sd">        &gt;&gt;&gt; p.apply(lambda x: x.shape, axis=(0,1))</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Panel, DataFrame, or Series</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">func</span>

        <span class="c1"># 2d-slabs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_2d</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># try ufunc like</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="c1"># 1d</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_1d</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># iter thru the axes</span>
        <span class="n">slice_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">slice_indexer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)</span>
        <span class="n">indlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">indlist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">indexer</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indlist</span><span class="p">,</span> <span class="n">slice_indexer</span><span class="p">)</span>
        <span class="n">planes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axi</span><span class="p">)</span> <span class="k">for</span> <span class="n">axi</span> <span class="ow">in</span> <span class="n">indlist</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indlist</span><span class="p">)</span>

        <span class="c1"># all the iteration points</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">(</span><span class="n">planes</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)):</span>

            <span class="c1"># construct the object</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
            <span class="n">indexer</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indlist</span><span class="p">,</span> <span class="n">slice_indexer</span><span class="p">)</span>

            <span class="n">obj</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)],</span> <span class="n">index</span><span class="o">=</span><span class="n">slice_axis</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

            <span class="c1"># increment the indexer</span>
            <span class="n">slice_indexer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">slice_indexer</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">)):</span>
                <span class="n">slice_indexer</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">slice_indexer</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># empty object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="c1"># same ndim as current</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">slice_axis</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">tranp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">indlist</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tranp</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="c1"># ndim-1 shape</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">axis_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">T</span>
            <span class="n">planes</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_return_type</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">planes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; handle 2-d slices, equiv to iterating over the other axis &quot;&quot;&quot;</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>

        <span class="c1"># construct slabs, in 2-d this is a DataFrame result</span>
        <span class="n">indexer_axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="n">indexer_axis</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">indexer_axis</span> <span class="o">=</span> <span class="n">indexer_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">indexer_axis</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax</span><span class="p">):</span>
            <span class="n">slicer</span><span class="p">[</span><span class="n">indexer_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">sliced</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

            <span class="n">obj</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">sliced</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_return_type</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">results</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">filter_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Panel.</span><span class="si">{0}</span><span class="s1"> does not implement &#39;</span>
                                      <span class="s1">&#39;numeric_only.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_number</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plane_axes</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">axis_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_return_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_return_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the type for the ndim of the result &quot;&quot;&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># need to assume they are the same</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">ndim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">compat</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">result</span><span class="p">))[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

                <span class="c1"># have a dict, so top-level is +1 dim</span>
                <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ndim</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># scalar</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c1"># same as self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="c1"># return the construction dictionary for these axes</span>
            <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="c1"># sliced</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_axes_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>

        <span class="k">raise</span> <span class="n">PandasError</span><span class="p">(</span><span class="s1">&#39;invalid _construct_return_type [self-&gt;</span><span class="si">%s</span><span class="s1">] &#39;</span>
                          <span class="s1">&#39;[result-&gt;</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_wrap_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plane_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_return_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;reindex&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">major_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minor_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">major_axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">major_axis</span> <span class="k">if</span> <span class="n">major_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                      <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">minor_axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">minor_axis</span> <span class="k">if</span> <span class="n">minor_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                      <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;minor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">major_axis</span><span class="o">=</span><span class="n">major_axis</span><span class="p">,</span>
                                          <span class="n">minor_axis</span><span class="o">=</span><span class="n">minor_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;rename&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">major_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minor_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">major_axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">major_axis</span> <span class="k">if</span> <span class="n">major_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                      <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">minor_axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">minor_axis</span> <span class="k">if</span> <span class="n">minor_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                      <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;minor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">major_axis</span><span class="o">=</span><span class="n">major_axis</span><span class="p">,</span>
                                         <span class="n">minor_axis</span><span class="o">=</span><span class="n">minor_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;reindex_axis&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                               <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                               <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                               <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;transpose&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># check if a list of axes was passed in instead as a</span>
        <span class="c1"># single *args element</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_string_like</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">args</span>

        <span class="k">if</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">axes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transpose() got multiple values for &quot;</span>
                            <span class="s2">&quot;keyword argument &#39;axes&#39;&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="p">())</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;fillna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                         <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                         <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of observations over requested axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {&#39;items&#39;, &#39;major&#39;, &#39;minor&#39;} or {0, 1, 2}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        count : DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s1">&#39;lags&#39;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s1">&#39;periods&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift index by desired number of periods with an optional time freq.</span>
<span class="sd">        The shifted data will not include the dropped periods and the</span>
<span class="sd">        shifted axis will be smaller than the original. This is different</span>
<span class="sd">        from the behavior of DataFrame.shift()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to move, can be positive or negative</span>
<span class="sd">        freq : DateOffset, timedelta, or time rule string, optional</span>
<span class="sd">        axis : {&#39;items&#39;, &#39;major&#39;, &#39;minor&#39;} or {0, 1, 2}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : Panel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">freq</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tshift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">slice_shift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tshift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">lsuffix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">rsuffix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join items with other Panel either on major and minor axes column</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Panel or list of Panels</span>
<span class="sd">            Index should be similar to one of the columns in this one</span>
<span class="sd">        how : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;}</span>
<span class="sd">            How to handle indexes of the two objects. Default: &#39;left&#39;</span>
<span class="sd">            for joining on index, None otherwise</span>
<span class="sd">            * left: use calling frame&#39;s index</span>
<span class="sd">            * right: use input frame&#39;s index</span>
<span class="sd">            * outer: form union of indexes</span>
<span class="sd">            * inner: use intersection of indexes</span>
<span class="sd">        lsuffix : string</span>
<span class="sd">            Suffix to use from left frame&#39;s overlapping columns</span>
<span class="sd">        rsuffix : string</span>
<span class="sd">            Suffix to use from right frame&#39;s overlapping columns</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        joined : Panel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tools.merge</span> <span class="k">import</span> <span class="n">concat</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Panel</span><span class="p">):</span>
            <span class="n">join_major</span><span class="p">,</span> <span class="n">join_minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_join_index</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">major</span><span class="o">=</span><span class="n">join_major</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="n">join_minor</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">major</span><span class="o">=</span><span class="n">join_major</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="n">join_minor</span><span class="p">)</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">lsuffix</span><span class="p">,</span> <span class="n">rsuffix</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">merged_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lsuffix</span> <span class="ow">or</span> <span class="n">rsuffix</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Suffixes not supported when passing &#39;</span>
                                 <span class="s1">&#39;multiple panels&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;outer&#39;</span>
                <span class="n">join_axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Right join not supported with multiple &#39;</span>
                                 <span class="s1">&#39;panels&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">join_axes</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">return</span> <span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                          <span class="n">join_axes</span><span class="o">=</span><span class="n">join_axes</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">raise_conflict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify Panel in place using non-NA values from passed</span>
<span class="sd">        Panel, or object coercible to Panel. Aligns on items</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Panel, or object coercible to Panel</span>
<span class="sd">        join : How to join individual DataFrames</span>
<span class="sd">            {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;}, default &#39;left&#39;</span>
<span class="sd">        overwrite : boolean, default True</span>
<span class="sd">            If True then overwrite values for common keys in the calling panel</span>
<span class="sd">        filter_func : callable(1d-array) -&gt; 1d-array&lt;boolean&gt;, default None</span>
<span class="sd">            Can choose to replace values other than NA. Return True for values</span>
<span class="sd">            that should be updated</span>
<span class="sd">        raise_conflict : bool</span>
<span class="sd">            If True, will raise an error if a DataFrame and other both</span>
<span class="sd">            contain data in the same place.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="n">axis_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">axis_values</span><span class="p">})</span>

        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">axis_values</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">frame</span><span class="p">],</span> <span class="n">join</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">,</span> <span class="n">filter_func</span><span class="p">,</span>
                               <span class="n">raise_conflict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_join_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">join_major</span><span class="p">,</span> <span class="n">join_minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">join_major</span><span class="p">,</span> <span class="n">join_minor</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">minor_axis</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
            <span class="n">join_major</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">major_axis</span><span class="p">)</span>
            <span class="n">join_minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
            <span class="n">join_major</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">major_axis</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">major_axis</span><span class="p">)</span>
            <span class="n">join_minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor_axis</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">join_major</span><span class="p">,</span> <span class="n">join_minor</span>

    <span class="c1"># miscellaneous data creation</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return a list of the axis indicies &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_axes_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the slice dictionary for these axes &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_SLICEMAP</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):],</span>
                         <span class="n">axes</span><span class="p">)])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_prep_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="c1"># NumPy strings are a pain, convert to object</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of dimensions required is </span><span class="si">{0}</span><span class="s2">, &quot;</span>
                             <span class="s2">&quot;but the number of dimensions of the &quot;</span>
                             <span class="s2">&quot;ndarray given was </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">,</span>
                                                            <span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_homogenize_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">intersect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conform set of _constructor_sliced-like objects to either</span>
<span class="sd">        an intersection of indices / columns or a union.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frames : dict</span>
<span class="sd">        intersect : boolean, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict of aligned results &amp; indicies</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># caller differs dict/ODict, presered type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">adj_frames</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">adj_frames</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adj_frames</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">axes_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_axes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">adj_frames</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">intersect</span><span class="o">=</span><span class="n">intersect</span><span class="p">))])</span>

        <span class="n">reindex_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_SLICEMAP</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">axes_dict</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">])</span>
        <span class="n">reindex_dict</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">adj_frames</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">reindex_dict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">axes_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="n">axes_dict</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">return</span> <span class="n">axes_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">intersect</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">raw_lengths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">have_raw_arrays</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">have_frames</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">):</span>
                <span class="n">have_frames</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">have_raw_arrays</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">raw_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">have_frames</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">_get_combined_index</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">intersect</span><span class="o">=</span><span class="n">intersect</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">have_raw_arrays</span><span class="p">:</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">raw_lengths</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ndarrays must match shape on axis </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">have_frames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Length of data and index must match&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([])</span>

        <span class="k">return</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_aggregate_operations</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">use_numexpr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add the operations to the cls; evaluate the doc strings again &quot;&quot;&quot;</span>

        <span class="c1"># doc strings substitors</span>
        <span class="n">_agg_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Wrapper method for </span><span class="si">%%</span><span class="s2">s</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">other : </span><span class="si">%s</span><span class="s2"> or </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">axis : {&quot;&quot;&quot;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Axis to broadcast over</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">def</span> <span class="nf">_panel_arith_method</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">str_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">fill_zeros</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">eval_kwargs</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                                                  <span class="n">raise_on_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eval_kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

                <span class="c1"># handles discrepancy between numpy and numexpr on division/mod</span>
                <span class="c1"># by 0 though, given that these are generally (always?)</span>
                <span class="c1"># non-scalars, I&#39;m not sure whether it&#39;s worth it at the moment</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">fill_zeros</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fill_zeros</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_op_descriptions</span><span class="p">:</span>
                <span class="n">op_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">op_desc</span> <span class="o">=</span> <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;reversed&#39;</span><span class="p">]:</span>
                    <span class="n">equiv</span> <span class="o">=</span> <span class="s1">&#39;other &#39;</span> <span class="o">+</span> <span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; panel&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">equiv</span> <span class="o">=</span> <span class="s1">&#39;panel &#39;</span> <span class="o">+</span> <span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; other&#39;</span>

                <span class="n">_op_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                </span><span class="si">%%</span><span class="s2">s of series and other, element-wise (binary operator `</span><span class="si">%%</span><span class="s2">s`).</span>
<span class="s2">                Equivalent to ``</span><span class="si">%%</span><span class="s2">s``.</span>

<span class="s2">                Parameters</span>
<span class="s2">                ----------</span>
<span class="s2">                other : </span><span class="si">%s</span><span class="s2"> or </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                       <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                axis : {&quot;&quot;&quot;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    Axis to broadcast over</span>

<span class="s2">                Returns</span>
<span class="s2">                -------</span>
<span class="s2">                &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">                See also</span>
<span class="s2">                --------</span>
<span class="s2">                &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s2">&quot;.</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="n">_op_doc</span> <span class="o">%</span> <span class="p">(</span><span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">],</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">equiv</span><span class="p">,</span>
                                 <span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="n">_agg_doc</span> <span class="o">%</span> <span class="n">name</span>

            <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

            <span class="n">f</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># add `div`, `mul`, `pow`, etc..</span>
        <span class="n">ops</span><span class="o">.</span><span class="n">add_flex_arithmetic_methods</span><span class="p">(</span>
            <span class="n">cls</span><span class="p">,</span> <span class="n">_panel_arith_method</span><span class="p">,</span> <span class="n">use_numexpr</span><span class="o">=</span><span class="n">use_numexpr</span><span class="p">,</span>
            <span class="n">flex_comp_method</span><span class="o">=</span><span class="n">ops</span><span class="o">.</span><span class="n">_comp_method_PANEL</span><span class="p">)</span>


<span class="n">Panel</span><span class="o">.</span><span class="n">_setup_axes</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;items&#39;</span><span class="p">,</span> <span class="s1">&#39;major_axis&#39;</span><span class="p">,</span> <span class="s1">&#39;minor_axis&#39;</span><span class="p">],</span> <span class="n">info_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">stat_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">aliases</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;major&#39;</span><span class="p">:</span> <span class="s1">&#39;major_axis&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;minor&#39;</span><span class="p">:</span> <span class="s1">&#39;minor_axis&#39;</span><span class="p">},</span>
                  <span class="n">slicers</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;major_axis&#39;</span><span class="p">:</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;minor_axis&#39;</span><span class="p">:</span> <span class="s1">&#39;columns&#39;</span><span class="p">})</span>

<span class="n">ops</span><span class="o">.</span><span class="n">add_special_arithmetic_methods</span><span class="p">(</span><span class="n">Panel</span><span class="p">,</span> <span class="o">**</span><span class="n">ops</span><span class="o">.</span><span class="n">panel_special_funcs</span><span class="p">)</span>
<span class="n">Panel</span><span class="o">.</span><span class="n">_add_aggregate_operations</span><span class="p">()</span>
<span class="n">Panel</span><span class="o">.</span><span class="n">_add_numeric_operations</span><span class="p">()</span>


<span class="c1"># legacy</span>
<span class="k">class</span> <span class="nc">WidePanel</span><span class="p">(</span><span class="n">Panel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># deprecation, #10892</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WidePanel is deprecated. Please use Panel&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">WidePanel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LongPanel</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># deprecation, #10892</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;LongPanel is deprecated. Please use DataFrame&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">LongPanel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <!-- <li><a href="http://project.invalid/">Project Homepage</a> &raquo;</li> -->
    
        <li class="nav-item nav-item-0"><a href="../../../index.html">UTkit 0.2</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Gerges Dib.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>